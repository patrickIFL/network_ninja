first install laravel then create a laravel project:

=> laravel new ninja_network


=> Started learning Laravel by installing Herd
Herd is like laragon. A platform for creating local laravel deployments.
learned about the different folders inside a laravel project.
in the laravel world,

=> eloquent = mongoose.

(ORM vs ODM)
=> Learned about blade. blade is used by laravel to generate views.

=> Started learning about routes.
As you can tell Route in larvel is similar to express.js
exept that return is equivalent to response.

<?php
use Illuminate\Support\Facades\Route;
use Inertia\Inertia;

Route::get('/', function () {
    return Inertia::render('welcome');
})->name('home');

What is Inertia.js?

Inertia.js is a bridge between modern frontend frameworks (like React, Vue, or Svelte) and backend frameworks (like Laravel, Rails, Django, etc.).

It lets you build single-page apps (SPAs) ‚Äî without creating a separate API or using something like Next.js or Laravel API + React app.

üß† Think of Inertia as the ‚Äúglue‚Äù that connects Laravel + React like a fullstack framework, without needing REST or GraphQL.

best to install these extensions:
laravel blade
php intellisense

learned about using routes (web.php)
Route::get('/ninjas', function () {
    return view('ninjas.index');
});
clicking this link will run the route navigating to the blade folder. separated by .
<a href="/ninjas" class="btn">Find Ninjas!</a>

declaring a key-value inside the route then passing it to blade view:
return view('ninjas.index', ["greeting" => "hello"]);

accessing it inside the view using blade syntax : {{  }}

learned about wildcards. Route::get('/ninjas/{id}')
in express, its equivalent is passing a dynamic value in the route to be accessed in the link.

learned about blade directives.
in JSX its like:
{greeting === "hello" ? 'hi' : 'goodbye'}
in Blade its like:
@if(true)
<p>Hi from inside the if statement</p>
@endif

note: remember, no {{ }}

Learned to run a @foreach loop to loop through each ninja.

@foreach ($ninjas as $ninja)
            <li>
                <a href="/ninjas/{{ $ninja["id"] }}">
                    {{ $ninja["name"] }}, {{ $ninja["skill"] }}
                </a>
            </li>
        @endforeach

Starter TechStack:
MERN <- Ecommerce (Patrick's Store), ArmorOfGod

Currently Studying TechStacks:
NEXT, Tailwind, Typscript, Prisma <- OnlyHorse

Laravel, React <- At Iformat, I'm doing this
Laravel, NEXT

learned about the layout.blade.php = component file
in your view file <x-layout> {{ your contents here }} <x-layout>
in your layout file, you do {{ $slot }}. slot will be the place where the children will be rendered.

you can use this to create reusable(react-like) components

<div class="card">
    {{ $slot }}
    {{-- <a href="{{ $attributes->get('href') }}"> --}}
    <a {{ $attributes }} class="btn">
        View Details
    </a>
</div>

{{ attributes->get('href') }} will only give the href we declared in the instance of our component.
<x-card href='/ninjas/{{ $ninja["id"] }}'>
while $attributes will extract it all then pass it to the declaration of our component.

attributes are legit attributes from html that can be passed to child components

props are non-legit attributes you can pass

how to pass props value to components

:highlight='true'

conditional props
:highlight="$ninja['skill'] > 70">

@props(['highlight' => false]) // default value

<div @class(['!bg-red-300' => $highlight, "card bg-gray-300"])>
// by default, class is "card" if highlight is true add the class.
// note that if you want to override the styles, add an important symbol

laravel serves our code but vite is the one serving the client. so you neet to add the directive in your layout.
@vite('resources/css/app.css') <== Path to your css file.


learned how to create a directive to convert tailwind to plain CSS

.card{
    @apply flex flex-col p-5 bg-gray-300 shadow-xl border border-gray-400;
}

learned that you can do components in larevel as you would with react.

learned about migrations

migration is a thing for SQL databases
A migration is just a versioned record of changes you make to your database schema ‚Äî the structure, not the data.

Think of it like Git for your database schema.
Every time you change a table ‚Äî add a column, rename something, change data types ‚Äî you create a migration file that describes that change in code.
MongoDB is schema-less ‚Äî you can just insert a new field into a document and it works:


php artisan make:migration create_todos_table <= create the table schema 
php artisan migrate <= create the table
php artisan migrate:rollback <= undo last migration

=> npx vite --host localhost --port 5173

=> php artisan make:model Ninja -mfs

1. ü™Ñ Model (app/Models/Ninja.php)
Represents a single table (ninjas) in your database.
You use it to interact with records:

2. üß± Migration (database/migrations/...create_ninjas_table.php)

Defines the schema (structure) of the ninjas table:

3. üß¨ Factory (database/factories/NinjaFactory.php)

Used to generate fake data ‚Äî super useful for testing or seeding.

eloquent is the ORM used in Laravel
$ninjas = Ninja::all()
$ninjas = Ninja::find(5)
$ninja->save()

protected $fillable = [ 'name', 'skill', 'bio' ];
this prevents multi-assignment attacks.

learned about Tinker
= a playground for PHP inside the laravel environment.

=> php artisan tinker

If you were to use the Ninja Model, type:
=> use App\Models\Ninja

Create a record in the database:
=> Ninja::create(['name' => 'mario', 'skill' => 75, 'bio'=>'athlethic plumber'])->toArray()

note: we add ("   ->toArray()   ") to see the output value. our tinker version does not do this automatically.
same with the command : Ninja::all()

note: you need to make sure fillable in Models/Ninja.php is filled. otherwise, you wond be able to make the changes.

Changes Made since Iformat:
Migration
Tinker
created Ninja Model.
added: Mario and Luigi to sqlite database: Ninja

Understood why we need to use ORM, 
instead of writing: 
SELECT * from ninjas we we use ORMs to represent the table then run commands for it. example, 
Ninja::all() 

this is also the case for mongoose.

Started Learning about : Model Factories
Factories are used to generate fake data.
return [ name' => 'mario', 'bio' => 'athletic plumber', 'skill' => 75 ];
this would make the value the same as the first data.

return [
            'name' => fake()->name(),
            'bio' => fake()->realText(500),
            'skill' => fake()->numberBetween(0, 100)
        ];

do this instead

Ninja::factory()->count(50)->create()   <== This will create a 50 record of Ninja based on the parameters you gave to factory.

DatabaseSeeder.php is the only seeder file that runs automatically on laravel startup.
so, run your seeder file here.


$this->call([
NinjaSeeder::class,
]);

php artisan migrate:fresh --seed
this drops all the tables in the database(clearing all the data)
then runs migrate to all the migration files at once (creating fresh tables)
--seed runs the databaseed.php then inside this file, we run the NinjaSeed which then creates all the dummy data again.

this simplifies the process when we are making new changes to our records.

MVC = Model, View, Controllers
Models = the data model, the schema we've been using
Views = how the user interacts with our website.
controllers = api, how our site interacts with each other.

php artisan make:controller NinjaController
creates a controller file inside app/http/controllers

This is like the controller JS that we typically use in express.js

Learned about fetching users in the database 
routes and controllers in laravel are very similar to express but laravel can generate a view also not only a response

in controllers, import the model
=> use App\Models\Ninja;

then create an endpoint:
example:
public function index(){
        $ninjas = Ninja::orderBy('id', 'asc')->get();
         return view('ninjas.index',
            ["ninjas" => $ninjas]);}
