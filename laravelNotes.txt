first install laravel then create a laravel project:

=> laravel new ninja_network


=> Started learning Laravel by installing Herd
Herd is like laragon. A platform for creating local laravel deployments.
learned about the different folders inside a laravel project.
in the laravel world,

=> eloquent = mongoose.

(ORM vs ODM)
=> Learned about blade. blade is used by laravel to generate views.

=> Started learning about routes.
As you can tell Route in larvel is similar to express.js
exept that return is equivalent to response.

<?php
use Illuminate\Support\Facades\Route;
use Inertia\Inertia;

Route::get('/', function () {
    return Inertia::render('welcome');
})->name('home');

What is Inertia.js?

Inertia.js is a bridge between modern frontend frameworks (like React, Vue, or Svelte) and backend frameworks (like Laravel, Rails, Django, etc.).

It lets you build single-page apps (SPAs) ‚Äî without creating a separate API or using something like Next.js or Laravel API + React app.

üß† Think of Inertia as the ‚Äúglue‚Äù that connects Laravel + React like a fullstack framework, without needing REST or GraphQL.

best to install these extensions:
laravel blade
php intellisense

learned about using routes (web.php)
Route::get('/ninjas', function () {
    return view('ninjas.index');
});
clicking this link will run the route navigating to the blade folder. separated by .
<a href="/ninjas" class="btn">Find Ninjas!</a>

declaring a key-value inside the route then passing it to blade view:
return view('ninjas.index', ["greeting" => "hello"]);

accessing it inside the view using blade syntax : {{  }}

learned about wildcards. Route::get('/ninjas/{id}')
in express, its equivalent is passing a dynamic value in the route to be accessed in the link.

learned about blade directives.
in JSX its like:
{greeting === "hello" ? 'hi' : 'goodbye'}
in Blade its like:
@if(true)
<p>Hi from inside the if statement</p>
@endif

note: remember, no {{ }}

Learned to run a @foreach loop to loop through each ninja.

@foreach ($ninjas as $ninja)
            <li>
                <a href="/ninjas/{{ $ninja["id"] }}">
                    {{ $ninja["name"] }}, {{ $ninja["skill"] }}
                </a>
            </li>
        @endforeach

Starter TechStack:
MERN <- Ecommerce (Patrick's Store), ArmorOfGod

Currently Studying TechStacks:
NEXT, Tailwind, Typscript, Prisma <- OnlyHorse

Laravel, React <- At Iformat, I'm doing this
Laravel, NEXT

learned about the layout.blade.php = component file
in your view file <x-layout> {{ your contents here }} <x-layout>
in your layout file, you do {{ $slot }}. slot will be the place where the children will be rendered.

you can use this to create reusable(react-like) components

<div class="card">
    {{ $slot }}
    {{-- <a href="{{ $attributes->get('href') }}"> --}}
    <a {{ $attributes }} class="btn">
        View Details
    </a>
</div>

{{ attributes->get('href') }} will only give the href we declared in the instance of our component.
<x-card href='/ninjas/{{ $ninja["id"] }}'>
while $attributes will extract it all then pass it to the declaration of our component.

attributes are legit attributes from html that can be passed to child components

props are non-legit attributes you can pass

how to pass props value to components

:highlight='true'

conditional props
:highlight="$ninja['skill'] > 70">

@props(['highlight' => false]) // default value

<div @class(['!bg-red-300' => $highlight, "card bg-gray-300"])>
// by default, class is "card" if highlight is true add the class.
// note that if you want to override the styles, add an important symbol

laravel serves our code but vite is the one serving the client. so you neet to add the directive in your layout.
@vite('resources/css/app.css') <== Path to your css file.


learned how to create a directive to convert tailwind to plain CSS

.card{
    @apply flex flex-col p-5 bg-gray-300 shadow-xl border border-gray-400;
}

learned that you can do components in larevel as you would with react.

learned about migrations

migration is a thing for SQL databases
A migration is just a versioned record of changes you make to your database schema ‚Äî the structure, not the data.

Think of it like Git for your database schema.
Every time you change a table ‚Äî add a column, rename something, change data types ‚Äî you create a migration file that describes that change in code.
MongoDB is schema-less ‚Äî you can just insert a new field into a document and it works:


php artisan make:migration create_todos_table <= create the table schema 
php artisan migrate <= create the table
php artisan migrate:rollback <= undo last migration

=> npx vite --host localhost --port 5173

=> php artisan make:model Ninja -mfs

1. ü™Ñ Model (app/Models/Ninja.php)
Represents a single table (ninjas) in your database.
You use it to interact with records:

2. üß± Migration (database/migrations/...create_ninjas_table.php)

Defines the schema (structure) of the ninjas table:

3. üß¨ Factory (database/factories/NinjaFactory.php)

Used to generate fake data ‚Äî super useful for testing or seeding.

eloquent is the ORM used in Laravel
$ninjas = Ninja::all()
$ninjas = Ninja::find(5)
$ninja->save()

protected $fillable = [ 'name', 'skill', 'bio' ];
this prevents multi-assignment attacks.

learned about Tinker
= a playground for PHP inside the laravel environment.

=> php artisan tinker

If you were to use the Ninja Model, type:
=> use App\Models\Ninja

Create a record in the database:
=> Ninja::create(['name' => 'mario', 'skill' => 75, 'bio'=>'athlethic plumber'])->toArray()

note: we add ("   ->toArray()   ") to see the output value. our tinker version does not do this automatically.
same with the command : Ninja::all()

note: you need to make sure fillable in Models/Ninja.php is filled. otherwise, you wond be able to make the changes.

Changes Made since Iformat:
Migration
Tinker
created Ninja Model.
added: Mario and Luigi to sqlite database: Ninja

--------------------------------------------------
Monday, 11/23/2025

Understood why we need to use ORM, 
instead of writing: 
SELECT * from ninjas we we use ORMs to represent the table then run commands for it. example, 
Ninja::all() 

this is also the case for mongoose.

Started Learning about : Model Factories
Factories are used to generate fake data.
return [ name' => 'mario', 'bio' => 'athletic plumber', 'skill' => 75 ];
this would make the value the same as the first data.

return [
            'name' => fake()->name(),
            'bio' => fake()->realText(500),
            'skill' => fake()->numberBetween(0, 100)
        ];

do this instead

Ninja::factory()->count(50)->create()   <== This will create a 50 record of Ninja based on the parameters you gave to factory.

DatabaseSeeder.php is the only seeder file that runs automatically on laravel startup.
so, run your seeder file here.


$this->call([
NinjaSeeder::class,
]);

php artisan migrate:fresh --seed
this drops all the tables in the database(clearing all the data)
then runs migrate to all the migration files at once (creating fresh tables)
--seed runs the databaseed.php then inside this file, we run the NinjaSeed which then creates all the dummy data again.

this simplifies the process when we are making new changes to our records.

MVC = Model, View, Controllers
Models = the data model, the schema we've been using
Views = how the user interacts with our website.
controllers = api, how our site interacts with each other.

php artisan make:controller NinjaController
creates a controller file inside app/http/controllers

This is like the controller JS that we typically use in express.js

Learned about fetching users in the database 
routes and controllers in laravel are very similar to express but laravel can generate a view also not only a response

in controllers, import the model
=> use App\Models\Ninja;

then create an endpoint:
example:
public function index(){
        $ninjas = Ninja::orderBy('id', 'asc')->get();
         return view('ninjas.index',
            ["ninjas" => $ninjas]);}

learned about the findOrFail function in eloquent: respond with the data or 404.
public function show($id){
        // route --> /ninjas/{$id}
        // fetch a single record
        $ninja = Ninja::findOrFail($id);
        return view('ninjas.show', ["ninja" => $ninja]);
    }

Proper usage of components
<x-card
href="/ninjas/{{ $ninja->id }}"
:highlight="$ninja->skill > 70"
:name="$ninja->name"
:skill="$ninja->skill"
/>

mapping through the object passed: show.blade.php -> <h2>Ninja ID: {{ $ninja -> id }}</h2>

Learned about named routes in Laravel.
First, create the name for the route. 
Route::get('/ninjas', [NinjaController::class, 'index'])->name('ninjas.index');
Then you can access the route like 
<a href="{{ route('ninjas.index') }}">List of Ninjas</a>
with wildcards:
href="{{ route('ninjas.show', $ninja->id) }}"

Making Bars:
<div class="w-full bg-gray-400 h-2 rounded-lg overflow-hidden">
    div class="bg-red-600 h-2 rounded-lg" style="width: {{$skill}}%;"></div>
</div>

Learned about Pagination: Pagination is when you have lots of data, you can separate the data in multiple pages. and when you move to page 1 only (10) is loaded then page 2 another 10 is loaded. (useful for performance)

change the fetch to this.
$ninjas = Ninja::orderBy('id', 'asc')->paginate(10);
then, add this to the bottom of you UL
{{ $ninjas->links()}}

Created a new Model called Dojo.
Learned about ForeignID. it is used to indicate the relationship of the value to the database.

$table->foreignId("dojo_id")->constrained()->onDelete('cascade');
constrained() means maintain the integrity of the relationship
onDelete('cascade') means that if we delete a dojo, every ninja in that dojo will also be deleted since the dojo does not exist.

Changes Made:
11/03/25¬†(Monday)

Accomplished Today:

Upskilled in Laravel
* Learned about Factories (a function to return dummy data)
* Learned about Seeds (an automation for databases)
* Learned about the importance of ORM (bridges code and database)
	(sets of functions to simplify DB interactions).
* Learned about database Models (Structure of the database) (Schema in Express)
* Learned about controllers and routes in Laravel. (same as Express.js, but with blade views)
* Learned about basic eloquent CRUD functions.
* Started Laravel CRUD implementation of the previous Techmax project.
* Learned about Naming Routes for easier modifications in the future.
* Learned about Foreign Keys. To indicate relationship of a value to a data in another folder
Stopped at #17 2:09
--------------------------------------------------------
11/4/2025 (Tuesday)
In Laravel by default, PHP always load different files. but you can make it an SPA like express does.
Route::get('/api/ninjas', function () {
    return [
        ['name' => 'Naruto'],
        ['name' => 'Sasuke'],
        ['name' => 'Kakashi']
    ];
});

That is why in the previous tutorials, 
$ninja = Ninja::findOrFail($id);
        return view('ninjas.show', ["ninja" => $ninja]);
We are actually returning 2 values. the response and a page.


We need to define the relationship of the two data.
a Ninja belongs to the dojo, then the Dojo has many Ninjas.
In the Ninja Model
public function dojo(){
        return $this->belongsTo(Dojo::class);
}
In the Dojo Model
public function ninjas(){
        return $this->hasMany(Ninja::class);
}

because you did this, you can populate the data of the dojo reference in the ninja.
Like this :
<x-card :dojo="$ninja->dojo->name" />
<x-card> {{ $ninja->dojo->name }} </x-card>

$users = User::all(); // Fetches all users


Learned about the difference between Lazy loading and Eager loading:
Lazy Loading:
üîç What happens in SQL:
SELECT * FROM users;
For each user:
SELECT * FROM posts WHERE user_id = ?;
If you have 100 users ‚Üí that‚Äôs 101 SQL queries üò±
This is called the N+1 problem.

foreach ($users as $user) {
    echo $user->posts; // This triggers a NEW query for each user üò©
}

Eager Loading:
üîç What happens in SQL:
SELECT * FROM users;
SELECT * FROM posts WHERE user_id IN (1, 2, 3, ...);
‚úÖ Only 2 queries total, even if there are 100 users.

$users = User::with('posts')->get(); // üëà Eager load posts
foreach ($users as $user) {
    echo $user->posts; // No new queries ‚Äî already loaded üéâ
}

In lazy loading you can see that in the index() controller, you fetched all the users. then you fetched for each user the dojo record. meaning, you fetched a total of 101 times (1 for all users + 100 iterations)

created the create ninja component:
Form with input boxes and a select.
fetched all() the list of dojos then passed it to the create view to be accessed and be looped by the select component.

Learnings Today:
-> Lazy Loading vs Eager Loading
-> returning a response only then using the data in a JS inside a blade.
-> Creating an object reference in a database using the foreign ID.

when creating a form, add this: 
@csrf
as the first part inside your form for cross site attacks defense.

Began to handle a POST request
the action for the form will be the api endpoint address the onSubmit button should call.
Like this:
<form
    action="{{ route("ninjas.store") }}"
    method="POST"
>

then in the post request controller, we get access to a parameter called, Request
Like this:

public function store(Request $request){
        // route --> /ninjas/{POST}
        // validate the values received from the client
        $validated = $request->validate([
            'name' => 'required|string|max:255',
            'skill' => 'required|integer|max:255|max:255',
            'bio' => 'required|string|min:20|max:1000',
            'dojo_id' => 'required|exists:dojos,id',
        ]);

        Ninja::create($validated);
        return redirect()->route('ninjas.index');
    }

Learned about inset shadows in tailwind
shadow-[inset_0_2px_4px_rgba(0,0,0,0.2)]

Learned about receiving form errors and retaining their old value.

@if($errors->any())
    @foreach ($errors->all() as $error)
        <li class="my-1 text-red-500">{{ $error }}</li>
    @endforeach
@endif

CRUD learned!

Learned Updating a Ninja via chatgpt

STEP # 1
Create 2 Routes, 2 Controllers,
1 new page(update(submission)), 1 new button(edit)

1.) Edit Page - For redirecting to the edit form.
2.) Update Page - For the updated values submission.

Route::post('/ninjas/{id}/edit', [NinjaController::class, 'edit'])->name('ninjas.edit');
=> Controller
public function edit($id){
        // route --> /ninjas/{POST}
        // handle POST request to store a new ninja record in the table.
        $ninja = Ninja::findOrFail($id);
        $dojos = Dojo::all();
        return view('ninjas.edit', [
            'ninja' => $ninja,
            'dojos' => $dojos,
        ]);
}

=> Controller
Route::post('/ninjas/{id}/update', [NinjaController::class, 'update'])->name('ninjas.update');
public function update(Request $request, $id){
        $validated = $request->validate([
            'name' => 'required|string|max:255',
            'skill' => 'required|integer|max:255|max:255',
            'bio' => 'required|string|min:20|max:1000',
            'dojo_id' => 'required|exists:dojos,id',
        ]);
        $ninja = Ninja::findOrFail($id);
        $ninja->update($validated);
        return redirect()->route('ninjas.index');
}

STEP # 2
create the edit.blade.php using the create a ninja template but pre-filled with the values of the passed ninja value.



